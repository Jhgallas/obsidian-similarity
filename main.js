/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var path = __toESM(require("path"));
var import_fs = require("fs");
var DEFAULT_SETTINGS = {
  nodePositions: []
};
var MyPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.ongoingBuffer = /* @__PURE__ */ new Set();
    this.reloadBuffer = /* @__PURE__ */ new Set();
    this.ongoingTimeouts = /* @__PURE__ */ new Map();
  }
  async onload() {
    this.setPythonCommand();
    await this.loadSettings();
    this.addCommands();
    await this.checkPythonRequirements();
    await this.runTokenizerScriptOnLoad();
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian.TFile) {
          console.log(`File modified: ${file.path}`);
          this.addToOngoingBuffer(file.path);
          this.addToReloadBuffer(file.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile) {
          console.log(`File moved or renamed from ${oldPath} to ${file.path}`);
          this.addToOngoingBuffer(file.path);
          this.addToReloadBuffer(file.path);
        }
      })
    );
  }
  addToOngoingBuffer(filePath) {
    if (!this.ongoingBuffer.has(filePath)) {
      this.ongoingBuffer.add(filePath);
      const timeout = setTimeout(() => {
        this.updateSingleFile(filePath);
        this.ongoingBuffer.delete(filePath);
        this.ongoingTimeouts.delete(filePath);
      }, 1e4);
      this.ongoingTimeouts.set(filePath, timeout);
    }
  }
  addToReloadBuffer(filePath) {
    if (!this.reloadBuffer.has(filePath)) {
      this.reloadBuffer.add(filePath);
    }
  }
  async runTokenizerScriptOnLoad() {
    const adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const envPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "obsidiansimilarity");
    const flagPath = path.join(envPath, "setup_complete.flag");
    try {
      await import_fs.promises.access(flagPath);
      await this.runTokenizerScript();
    } catch (error) {
      console.error("Tokenizer script cannot run: Environment setup is not complete.");
      new import_obsidian.Notice("Tokenizer script cannot run: Please ensure all packages are installed.");
    }
  }
  setPythonCommand() {
    this.pythonCommand = navigator.platform.startsWith("Win") ? "python" : "python3";
    console.log("Using Python command:", this.pythonCommand);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async checkPythonRequirements() {
    const adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const envPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "obsidiansimilarity");
    const requirementsPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "requirements.txt");
    const flagPath = path.join(envPath, "setup_complete.flag");
    try {
      await import_fs.promises.access(flagPath);
      console.log("Environment setup is already complete.");
      return;
    } catch (error) {
      console.log("Environment setup is not complete. Starting setup...");
    }
    const notice = new import_obsidian.Notice("Setting up Python environment for Obsidian Similarity Toolkit. Please wait...", 6e5);
    let environmentCreated = false;
    try {
      await import_fs.promises.stat(envPath);
      console.log("Virtual environment already exists.");
    } catch (error) {
      if (error.code === "ENOENT") {
        console.log("Virtual environment not found, attempting to create one...");
        try {
          const createEnvProcess = (0, import_child_process.spawn)(this.pythonCommand, ["-m", "venv", envPath]);
          await new Promise((resolve, reject) => {
            createEnvProcess.on("close", (code) => {
              if (code === 0) {
                console.log("Virtual environment created successfully.");
                new import_obsidian.Notice("Environment folder succesfully created.");
                environmentCreated = true;
                resolve(code);
              } else {
                console.error(`Failed to create virtual environment with exit code: ${code}`);
                new import_obsidian.Notice("Failed to create virtual environment. Please check your Python installation.");
                reject(new Error(`Failed to create virtual environment with code ${code}`));
              }
            });
          });
        } catch (error2) {
          console.error("Error during virtual environment creation:", error2);
          new import_obsidian.Notice("Failed to create virtual environment. Please check your Python installation.");
          return;
        }
      } else {
        console.error("Error checking virtual environment:", error);
        new import_obsidian.Notice("Error checking virtual environment. Please check your permissions and file system.");
        return;
      }
    }
    if (environmentCreated) {
      let pythonExecutable = path.join(envPath, navigator.platform.startsWith("Win") ? "Scripts\\python.exe" : "bin/python3");
      const installCmd = (0, import_child_process.spawn)(pythonExecutable, ["-m", "pip", "install", "-r", requirementsPath]);
      installCmd.stdout.on("data", (data) => {
        console.log(data.toString());
      });
      installCmd.stderr.on("data", (data) => {
        const errorOutput = data.toString();
        console.error(`stderr: ${errorOutput}`);
        new import_obsidian.Notice(`Error during package installation: ${errorOutput}`);
      });
      await new Promise((resolve, reject) => {
        installCmd.on("close", (code) => {
          if (code === 0) {
            console.log("All packages installed successfully.");
            new import_obsidian.Notice("All packages installed successfully.");
            resolve();
          } else {
            console.error(`Failed to install packages with code ${code}`);
            new import_obsidian.Notice(`Failed to install packages. Please check the installation logs.`);
            reject(new Error(`Failed to install packages with code ${code}`));
          }
        });
      });
      try {
        await import_fs.promises.writeFile(path.join(envPath, "setup_complete.flag"), "Setup complete");
        new import_obsidian.Notice("Environment setup is complete.");
        setTimeout(() => notice.hide(), 1e3);
      } catch (error) {
        console.error("Failed to create setup complete flag file:", error);
        new import_obsidian.Notice("Failed to create setup complete flag file. Please check your permissions and file system.");
      }
    } else {
      console.log("Skipping package installation as the virtual environment already exists.");
    }
  }
  addCommands() {
    this.addCommand({
      id: "similarity-graph-position",
      name: "Organize graph with similarity",
      callback: async () => {
        const notice = new import_obsidian.Notice("Organizing graph based on similarity...", 6e4);
        console.log("Attempting to run T-SNE and restore node positions...");
        await this.runGraphTsne();
        const graphLeaf = this.findGraphLeaf();
        if (graphLeaf) {
          console.log("Graph leaf found, restoring data...");
          this.restoreGraphData(graphLeaf);
        } else {
          console.log("No graph leaf found or multiple leaves present.");
          new import_obsidian.Notice("Graph view must be singular and active");
        }
        notice.hide();
      }
    });
    this.addCommand({
      id: "manual-run-embeddings",
      name: "Manually re-calculate embeddings",
      callback: () => this.runTokenizerScript()
    });
    this.addCommand({
      id: "update-single-file",
      name: "Update embedding for current file",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian.Notice("No file is currently active.");
          return;
        }
        this.updateSingleFile(activeFile.path);
      }
    });
  }
  findGraphLeaf() {
    let graphLeaves = this.app.workspace.getLeavesOfType("graph");
    console.log(`Found ${graphLeaves.length} graph leaves.`);
    if (graphLeaves.length === 1) {
      return graphLeaves[0];
    }
    return null;
  }
  restoreGraphData(graphLeaf) {
    if (!graphLeaf) {
      console.log("No graph leaf provided to restoreGraphData.");
      return;
    }
    const nodePositions = this.settings.nodePositions;
    if (nodePositions.length === 0) {
      console.log("No node positions available in settings.");
      return;
    }
    nodePositions.forEach((node) => {
      console.log(`Restoring position for node ${node.id}: (${node.x}, ${node.y})`);
      graphLeaf.view.renderer.worker.postMessage({
        forceNode: {
          id: node.id,
          x: node.x,
          y: node.y
        }
      });
    });
    graphLeaf.view.renderer.worker.postMessage({
      run: true,
      alpha: 0.1
    });
    console.log("Redraw triggered.");
  }
  async runTokenizerScript() {
    let adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const envPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "obsidiansimilarity");
    const flagPath = path.join(envPath, "setup_complete.flag");
    const csvPath = path.join(".obsidian", "plugins", "obsidian-similarity-toolkit", "embeddings.csv");
    try {
      await import_fs.promises.access(flagPath);
    } catch (error) {
      console.error("Environment setup is not complete. Please ensure all packages are installed.");
      new import_obsidian.Notice("Environment setup is not complete. Please ensure all packages are installed.");
      return;
    }
    const pythonExecutable = path.join(envPath, navigator.platform.startsWith("Win") ? "Scripts\\python.exe" : "bin/python3");
    const scriptPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "tokenizer.py");
    let notice;
    try {
      await this.app.vault.adapter.read(csvPath);
      notice = new import_obsidian.Notice("Vault embeddings will be updated");
    } catch (error) {
      notice = new import_obsidian.Notice("Creating initial embeddings for vault", 6e5);
    }
    const process = (0, import_child_process.spawn)(pythonExecutable, [scriptPath, basePath]);
    let csvContent = "";
    process.stdout.on("data", (data) => {
      csvContent += data.toString();
    });
    process.stderr.on("data", (data) => {
      console.error(`stderr: ${data}`);
    });
    process.on("close", (code) => {
      if (code !== 0) {
        console.error(`Process exited with code ${code}`);
        new import_obsidian.Notice("Error running tokenizer script.");
      } else {
        csvContent = csvContent.trim();
        const lines = csvContent.split("\n").filter((line) => line.trim() !== "");
        const updatedCsvContent = lines.join("\n");
        this.app.vault.adapter.write(csvPath, updatedCsvContent).then(() => {
          console.log("Vault embeddings updated successfully");
          new import_obsidian.Notice("Vault embeddings updated successfully.");
          this.reloadBuffer.forEach((filePath) => {
            this.updateSingleFile(filePath);
          });
          this.reloadBuffer.clear();
        }).catch((writeError) => {
          console.error(`Error writing embeddings file: ${writeError}`);
          new import_obsidian.Notice(`Error writing embeddings file: ${writeError}`);
        });
      }
      notice.hide();
    });
  }
  async runGraphTsne() {
    let adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const envPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "obsidiansimilarity");
    const scriptPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "sne-to-data.py");
    const csvPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "embeddings.csv");
    const pythonExecutable = path.join(envPath, navigator.platform.startsWith("Win") ? "Scripts\\python.exe" : "bin/python3");
    const process = (0, import_child_process.spawn)(pythonExecutable, [scriptPath, csvPath]);
    let output = "";
    process.stdout.on("data", (data) => {
      output += data.toString();
    });
    process.stderr.on("data", (data) => {
      console.error(`stderr: ${data}`);
    });
    return new Promise((resolve, reject) => {
      process.on("close", (code) => {
        if (code !== 0) {
          console.error(`Process exited with code ${code}`);
          new import_obsidian.Notice("Error running T-SNE script.");
          reject(`Process exited with code ${code}`);
        } else {
          try {
            const result = JSON.parse(output);
            this.settings.nodePositions = result.nodePositions;
            this.saveSettings();
            new import_obsidian.Notice("Node positions updated according to T-SNE");
            resolve();
          } catch (error) {
            console.error("Failed to parse output:", error);
            new import_obsidian.Notice("Failed to update node positions.");
            reject(error);
          }
        }
      });
    });
  }
  async updateSingleFile(filePath) {
    const adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const absoluteFilePath = path.join(basePath, filePath);
    const scriptPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "tokenizer.py");
    const process = (0, import_child_process.spawn)(this.pythonCommand, [scriptPath, absoluteFilePath]);
    process.stderr.on("data", (data) => {
      console.error(`stderr: ${data}`);
    });
    process.on("close", async (code) => {
      if (code !== 0) {
        console.error(`Process exited with code ${code}`);
        new import_obsidian.Notice("Error updating embedding.");
        return;
      }
      let newEmbedding = "";
      process.stdout.on("data", (data) => {
        newEmbedding += data.toString();
      });
      const csvPath = path.join(".obsidian", "plugins", "obsidian-similarity-toolkit", "embeddings.csv");
      let csvContent = await this.app.vault.adapter.read(csvPath);
      let lines = csvContent.split("\n");
      const index = lines.findIndex((line) => line.startsWith(filePath + ","));
      if (index !== -1) {
        lines.splice(index, 1);
      }
      lines.push(newEmbedding.trim());
      const updatedCsvContent = lines.filter((line) => line.trim() !== "").join("\n");
      await this.app.vault.adapter.write(csvPath, updatedCsvContent);
      console.log(`Updated embeddings for ${filePath}`);
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIEZpbGVTeXN0ZW1BZGFwdGVyLCBOb3RpY2UsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgZXhlYywgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcblxuaW50ZXJmYWNlIE5vZGVQb3NpdGlvbiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XG4gICAgbm9kZVBvc2l0aW9uczogTm9kZVBvc2l0aW9uW107XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE15UGx1Z2luU2V0dGluZ3MgPSB7XG4gICAgbm9kZVBvc2l0aW9uczogW10sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncztcbiAgICBweXRob25Db21tYW5kOiBzdHJpbmc7XG4gICAgb25nb2luZ0J1ZmZlcjogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gICAgcmVsb2FkQnVmZmVyOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgICBvbmdvaW5nVGltZW91dHM6IE1hcDxzdHJpbmcsIE5vZGVKUy5UaW1lb3V0PiA9IG5ldyBNYXAoKTtcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgdGhpcy5zZXRQeXRob25Db21tYW5kKCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZHMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jaGVja1B5dGhvblJlcXVpcmVtZW50cygpO1xuICAgICAgICBhd2FpdCB0aGlzLnJ1blRva2VuaXplclNjcmlwdE9uTG9hZCgpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgZmlsZSBtb2RpZmljYXRpb25zXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKCdtb2RpZnknLCAoZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZpbGUgbW9kaWZpZWQ6ICR7ZmlsZS5wYXRofWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRvT25nb2luZ0J1ZmZlcihmaWxlLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRvUmVsb2FkQnVmZmVyKGZpbGUucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIGZpbGUgcmVuYW1lcyBhbmQgbW92ZXNcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQub24oJ3JlbmFtZScsIChmaWxlLCBvbGRQYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmlsZSBtb3ZlZCBvciByZW5hbWVkIGZyb20gJHtvbGRQYXRofSB0byAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb09uZ29pbmdCdWZmZXIoZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb1JlbG9hZEJ1ZmZlcihmaWxlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYWRkVG9PbmdvaW5nQnVmZmVyKGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZ29pbmdCdWZmZXIuaGFzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5vbmdvaW5nQnVmZmVyLmFkZChmaWxlUGF0aCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaW5nbGVGaWxlKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uZ29pbmdCdWZmZXIuZGVsZXRlKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uZ29pbmdUaW1lb3V0cy5kZWxldGUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgfSwgMTAwMDApOyAgLy8gMTAgc2Vjb25kcyBkZWxheVxuICAgICAgICAgICAgdGhpcy5vbmdvaW5nVGltZW91dHMuc2V0KGZpbGVQYXRoLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFRvUmVsb2FkQnVmZmVyKGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbG9hZEJ1ZmZlci5oYXMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZEJ1ZmZlci5hZGQoZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcnVuVG9rZW5pemVyU2NyaXB0T25Mb2FkKCkge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcbiAgICAgICAgbGV0IGJhc2VQYXRoID0gJyc7XG4gICAgICAgIGlmIChhZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gYWRhcHRlci5nZXRCYXNlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW52UGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgJy5vYnNpZGlhbicsICdwbHVnaW5zJywgJ29ic2lkaWFuLXNpbWlsYXJpdHktdG9vbGtpdCcsICdQeXRob24nLCAnb2JzaWRpYW5zaW1pbGFyaXR5Jyk7XG4gICAgICAgIGNvbnN0IGZsYWdQYXRoID0gcGF0aC5qb2luKGVudlBhdGgsICdzZXR1cF9jb21wbGV0ZS5mbGFnJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZzLmFjY2VzcyhmbGFnUGF0aCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1blRva2VuaXplclNjcmlwdCgpOyAgLy8gUnVuIHRva2VuaXplciBzY3JpcHQgaWYgc2V0dXAgaXMgY29tcGxldGVcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUb2tlbml6ZXIgc2NyaXB0IGNhbm5vdCBydW46IEVudmlyb25tZW50IHNldHVwIGlzIG5vdCBjb21wbGV0ZS5cIik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiVG9rZW5pemVyIHNjcmlwdCBjYW5ub3QgcnVuOiBQbGVhc2UgZW5zdXJlIGFsbCBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXHRzZXRQeXRob25Db21tYW5kKCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIFB5dGhvbiBjb21tYW5kIGJhc2VkIG9uIHRoZSBwbGF0Zm9ybVxuICAgICAgICB0aGlzLnB5dGhvbkNvbW1hbmQgPSBuYXZpZ2F0b3IucGxhdGZvcm0uc3RhcnRzV2l0aCgnV2luJykgPyAncHl0aG9uJyA6ICdweXRob24zJztcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2luZyBQeXRob24gY29tbWFuZDpcIiwgdGhpcy5weXRob25Db21tYW5kKTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cblx0YXN5bmMgY2hlY2tQeXRob25SZXF1aXJlbWVudHMoKSB7XG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG5cdFx0bGV0IGJhc2VQYXRoID0gJyc7XG5cdFx0aWYgKGFkYXB0ZXIgaW5zdGFuY2VvZiBGaWxlU3lzdGVtQWRhcHRlcikge1xuXHRcdFx0YmFzZVBhdGggPSBhZGFwdGVyLmdldEJhc2VQYXRoKCk7XG5cdFx0fVxuXHRcblx0XHRjb25zdCBlbnZQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCAnLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ1B5dGhvbicsICdvYnNpZGlhbnNpbWlsYXJpdHknKTtcblx0XHRjb25zdCByZXF1aXJlbWVudHNQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCAnLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ1B5dGhvbicsICdyZXF1aXJlbWVudHMudHh0Jyk7XG5cdFx0Y29uc3QgZmxhZ1BhdGggPSBwYXRoLmpvaW4oZW52UGF0aCwgJ3NldHVwX2NvbXBsZXRlLmZsYWcnKTtcblx0XG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHNldHVwIGNvbXBsZXRlIGZsYWcgZXhpc3RzXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGZzLmFjY2VzcyhmbGFnUGF0aCk7XG5cdFx0XHRjb25zb2xlLmxvZyhcIkVudmlyb25tZW50IHNldHVwIGlzIGFscmVhZHkgY29tcGxldGUuXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIkVudmlyb25tZW50IHNldHVwIGlzIG5vdCBjb21wbGV0ZS4gU3RhcnRpbmcgc2V0dXAuLi5cIik7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRpbmcgYSBub3RpY2Ugd2l0aCBhIGR1cmF0aW9uIG9mIDEwIG1pbnV0ZXMgKDYwMDAwMCBtaWxsaXNlY29uZHMpXG5cdFx0Y29uc3Qgbm90aWNlID0gbmV3IE5vdGljZShcIlNldHRpbmcgdXAgUHl0aG9uIGVudmlyb25tZW50IGZvciBPYnNpZGlhbiBTaW1pbGFyaXR5IFRvb2xraXQuIFBsZWFzZSB3YWl0Li4uXCIsIDYwMDAwMCk7XG5cblx0XHRsZXQgZW52aXJvbm1lbnRDcmVhdGVkID0gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGZzLnN0YXQoZW52UGF0aCk7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlZpcnR1YWwgZW52aXJvbm1lbnQgYWxyZWFkeSBleGlzdHMuXCIpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCcpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJWaXJ0dWFsIGVudmlyb25tZW50IG5vdCBmb3VuZCwgYXR0ZW1wdGluZyB0byBjcmVhdGUgb25lLi4uXCIpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IGNyZWF0ZUVudlByb2Nlc3MgPSBzcGF3bih0aGlzLnB5dGhvbkNvbW1hbmQsIFsnLW0nLCAndmVudicsIGVudlBhdGhdKTtcblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRcdFx0XHRjcmVhdGVFbnZQcm9jZXNzLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChjb2RlID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJWaXJ0dWFsIGVudmlyb25tZW50IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LlwiKTtcblx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiRW52aXJvbm1lbnQgZm9sZGVyIHN1Y2Nlc2Z1bGx5IGNyZWF0ZWQuXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGVudmlyb25tZW50Q3JlYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShjb2RlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHZpcnR1YWwgZW52aXJvbm1lbnQgd2l0aCBleGl0IGNvZGU6ICR7Y29kZX1gKTtcblx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiRmFpbGVkIHRvIGNyZWF0ZSB2aXJ0dWFsIGVudmlyb25tZW50LiBQbGVhc2UgY2hlY2sgeW91ciBQeXRob24gaW5zdGFsbGF0aW9uLlwiKTtcblx0XHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHZpcnR1YWwgZW52aXJvbm1lbnQgd2l0aCBjb2RlICR7Y29kZX1gKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgdmlydHVhbCBlbnZpcm9ubWVudCBjcmVhdGlvbjpcIiwgZXJyb3IpO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJGYWlsZWQgdG8gY3JlYXRlIHZpcnR1YWwgZW52aXJvbm1lbnQuIFBsZWFzZSBjaGVjayB5b3VyIFB5dGhvbiBpbnN0YWxsYXRpb24uXCIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGNoZWNraW5nIHZpcnR1YWwgZW52aXJvbm1lbnQ6XCIsIGVycm9yKTtcblx0XHRcdFx0bmV3IE5vdGljZShcIkVycm9yIGNoZWNraW5nIHZpcnR1YWwgZW52aXJvbm1lbnQuIFBsZWFzZSBjaGVjayB5b3VyIHBlcm1pc3Npb25zIGFuZCBmaWxlIHN5c3RlbS5cIik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGlmIChlbnZpcm9ubWVudENyZWF0ZWQpIHtcblx0XHRcdGxldCBweXRob25FeGVjdXRhYmxlID0gcGF0aC5qb2luKGVudlBhdGgsIG5hdmlnYXRvci5wbGF0Zm9ybS5zdGFydHNXaXRoKCdXaW4nKSA/ICdTY3JpcHRzXFxcXHB5dGhvbi5leGUnIDogJ2Jpbi9weXRob24zJyk7XG5cdFx0XHRjb25zdCBpbnN0YWxsQ21kID0gc3Bhd24ocHl0aG9uRXhlY3V0YWJsZSwgWyctbScsICdwaXAnLCAnaW5zdGFsbCcsICctcicsIHJlcXVpcmVtZW50c1BhdGhdKTtcblx0XG5cdFx0XHRpbnN0YWxsQ21kLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGRhdGEudG9TdHJpbmcoKSk7XG5cdFx0XHR9KTtcblx0XG5cdFx0XHRpbnN0YWxsQ21kLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGVycm9yT3V0cHV0ID0gZGF0YS50b1N0cmluZygpO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGBzdGRlcnI6ICR7ZXJyb3JPdXRwdXR9YCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEVycm9yIGR1cmluZyBwYWNrYWdlIGluc3RhbGxhdGlvbjogJHtlcnJvck91dHB1dH1gKTtcblx0XHRcdH0pO1xuXHRcblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0aW5zdGFsbENtZC5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuXHRcdFx0XHRcdGlmIChjb2RlID09PSAwKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkFsbCBwYWNrYWdlcyBpbnN0YWxsZWQgc3VjY2Vzc2Z1bGx5LlwiKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJBbGwgcGFja2FnZXMgaW5zdGFsbGVkIHN1Y2Nlc3NmdWxseS5cIik7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBpbnN0YWxsIHBhY2thZ2VzIHdpdGggY29kZSAke2NvZGV9YCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gaW5zdGFsbCBwYWNrYWdlcy4gUGxlYXNlIGNoZWNrIHRoZSBpbnN0YWxsYXRpb24gbG9ncy5gKTtcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBpbnN0YWxsIHBhY2thZ2VzIHdpdGggY29kZSAke2NvZGV9YCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XG5cdFx0XHQvLyBBZnRlciBhbGwgcGFja2FnZXMgYXJlIGluc3RhbGxlZCBzdWNjZXNzZnVsbHlcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IGZzLndyaXRlRmlsZShwYXRoLmpvaW4oZW52UGF0aCwgJ3NldHVwX2NvbXBsZXRlLmZsYWcnKSwgJ1NldHVwIGNvbXBsZXRlJyk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJFbnZpcm9ubWVudCBzZXR1cCBpcyBjb21wbGV0ZS5cIik7XG5cdFx0XHRcdC8vIEhpZGUgdGhlIG5vdGljZSBhZnRlciAxIHNlY29uZCAoMTAwMCBtaWxsaXNlY29uZHMpXG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4gbm90aWNlLmhpZGUoKSwgMTAwMCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBzZXR1cCBjb21wbGV0ZSBmbGFnIGZpbGU6XCIsIGVycm9yKTtcblx0XHRcdFx0bmV3IE5vdGljZShcIkZhaWxlZCB0byBjcmVhdGUgc2V0dXAgY29tcGxldGUgZmxhZyBmaWxlLiBQbGVhc2UgY2hlY2sgeW91ciBwZXJtaXNzaW9ucyBhbmQgZmlsZSBzeXN0ZW0uXCIpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlNraXBwaW5nIHBhY2thZ2UgaW5zdGFsbGF0aW9uIGFzIHRoZSB2aXJ0dWFsIGVudmlyb25tZW50IGFscmVhZHkgZXhpc3RzLlwiKTtcblx0XHR9XG5cdH1cblxuXHRhZGRDb21tYW5kcygpIHtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3NpbWlsYXJpdHktZ3JhcGgtcG9zaXRpb24nLFxuXHRcdFx0bmFtZTogJ09yZ2FuaXplIGdyYXBoIHdpdGggc2ltaWxhcml0eScsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4geyAgLy8gTWFrZSB0aGUgY2FsbGJhY2sgYXN5bmMgdG8gdXNlIGF3YWl0XG5cdFx0XHRcdGNvbnN0IG5vdGljZSA9IG5ldyBOb3RpY2UoXCJPcmdhbml6aW5nIGdyYXBoIGJhc2VkIG9uIHNpbWlsYXJpdHkuLi5cIiwgNjAwMDApOyAvLyBOb3RpY2Ugc2hvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24gb25seVxuXHRcblx0XHRcdFx0Y29uc29sZS5sb2coXCJBdHRlbXB0aW5nIHRvIHJ1biBULVNORSBhbmQgcmVzdG9yZSBub2RlIHBvc2l0aW9ucy4uLlwiKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5ydW5HcmFwaFRzbmUoKTsgIC8vIEF3YWl0cyB0aGUgY29tcGxldGlvbiBvZiBULVNORSBwcm9jZXNzaW5nXG5cdFxuXHRcdFx0XHRjb25zdCBncmFwaExlYWYgPSB0aGlzLmZpbmRHcmFwaExlYWYoKTtcblx0XHRcdFx0aWYgKGdyYXBoTGVhZikge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiR3JhcGggbGVhZiBmb3VuZCwgcmVzdG9yaW5nIGRhdGEuLi5cIik7XG5cdFx0XHRcdFx0dGhpcy5yZXN0b3JlR3JhcGhEYXRhKGdyYXBoTGVhZik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJObyBncmFwaCBsZWFmIGZvdW5kIG9yIG11bHRpcGxlIGxlYXZlcyBwcmVzZW50LlwiKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdHcmFwaCB2aWV3IG11c3QgYmUgc2luZ3VsYXIgYW5kIGFjdGl2ZScpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRub3RpY2UuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pOyBcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ21hbnVhbC1ydW4tZW1iZWRkaW5ncycsXG5cdFx0XHRuYW1lOiAnTWFudWFsbHkgcmUtY2FsY3VsYXRlIGVtYmVkZGluZ3MnLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHRoaXMucnVuVG9rZW5pemVyU2NyaXB0KClcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3VwZGF0ZS1zaW5nbGUtZmlsZScsXG5cdFx0XHRuYW1lOiAnVXBkYXRlIGVtYmVkZGluZyBmb3IgY3VycmVudCBmaWxlJyxcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuXHRcdFx0XHRpZiAoIWFjdGl2ZUZpbGUpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTm8gZmlsZSBpcyBjdXJyZW50bHkgYWN0aXZlLlwiKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGVTaW5nbGVGaWxlKGFjdGl2ZUZpbGUucGF0aCk7XG5cdFx0XHR9XG5cdFx0fSk7XG4gICAgfVxuXG4gICAgZmluZEdyYXBoTGVhZigpOiBhbnkge1xuICAgICAgICBsZXQgZ3JhcGhMZWF2ZXMgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKCdncmFwaCcpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtncmFwaExlYXZlcy5sZW5ndGh9IGdyYXBoIGxlYXZlcy5gKTtcbiAgICAgICAgaWYgKGdyYXBoTGVhdmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdyYXBoTGVhdmVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlc3RvcmVHcmFwaERhdGEoZ3JhcGhMZWFmOiBhbnkpIHtcbiAgICAgICAgaWYgKCFncmFwaExlYWYpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gZ3JhcGggbGVhZiBwcm92aWRlZCB0byByZXN0b3JlR3JhcGhEYXRhLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbnM6IE5vZGVQb3NpdGlvbltdID0gdGhpcy5zZXR0aW5ncy5ub2RlUG9zaXRpb25zO1xuICAgICAgICBpZiAobm9kZVBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gbm9kZSBwb3NpdGlvbnMgYXZhaWxhYmxlIGluIHNldHRpbmdzLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVQb3NpdGlvbnMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFJlc3RvcmluZyBwb3NpdGlvbiBmb3Igbm9kZSAke25vZGUuaWR9OiAoJHtub2RlLnh9LCAke25vZGUueX0pYCk7XG4gICAgICAgICAgICBncmFwaExlYWYudmlldy5yZW5kZXJlci53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGZvcmNlTm9kZToge1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgeDogbm9kZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiBub2RlLnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRm9yY2UgYSByZWRyYXcgaGVyZVxuICAgICAgICBncmFwaExlYWYudmlldy5yZW5kZXJlci53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgcnVuOiB0cnVlLFxuICAgICAgICAgICAgYWxwaGE6IDAuMVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZWRyYXcgdHJpZ2dlcmVkLlwiKTtcbiAgICB9XG5cblx0YXN5bmMgcnVuVG9rZW5pemVyU2NyaXB0KCkge1xuXHRcdGxldCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblx0XHRsZXQgYmFzZVBhdGggPSAnJztcblx0XHRpZiAoYWRhcHRlciBpbnN0YW5jZW9mIEZpbGVTeXN0ZW1BZGFwdGVyKSB7XG5cdFx0XHRiYXNlUGF0aCA9IGFkYXB0ZXIuZ2V0QmFzZVBhdGgoKTtcblx0XHR9XG5cdFxuXHRcdGNvbnN0IGVudlBhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsICcub2JzaWRpYW4nLCAncGx1Z2lucycsICdvYnNpZGlhbi1zaW1pbGFyaXR5LXRvb2xraXQnLCAnUHl0aG9uJywgJ29ic2lkaWFuc2ltaWxhcml0eScpO1xuXHRcdGNvbnN0IGZsYWdQYXRoID0gcGF0aC5qb2luKGVudlBhdGgsICdzZXR1cF9jb21wbGV0ZS5mbGFnJyk7XG5cdFx0Y29uc3QgY3N2UGF0aCA9IHBhdGguam9pbignLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ2VtYmVkZGluZ3MuY3N2Jyk7IC8vIEtlZXAgdGhlIG9yaWdpbmFsIHBhdGggYXMgcmVxdWVzdGVkXG5cdFxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBmcy5hY2Nlc3MoZmxhZ1BhdGgpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRW52aXJvbm1lbnQgc2V0dXAgaXMgbm90IGNvbXBsZXRlLiBQbGVhc2UgZW5zdXJlIGFsbCBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkLlwiKTtcblx0XHRcdG5ldyBOb3RpY2UoXCJFbnZpcm9ubWVudCBzZXR1cCBpcyBub3QgY29tcGxldGUuIFBsZWFzZSBlbnN1cmUgYWxsIHBhY2thZ2VzIGFyZSBpbnN0YWxsZWQuXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0Y29uc3QgcHl0aG9uRXhlY3V0YWJsZSA9IHBhdGguam9pbihlbnZQYXRoLCBuYXZpZ2F0b3IucGxhdGZvcm0uc3RhcnRzV2l0aCgnV2luJykgPyAnU2NyaXB0c1xcXFxweXRob24uZXhlJyA6ICdiaW4vcHl0aG9uMycpO1xuXHRcdGNvbnN0IHNjcmlwdFBhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsICcub2JzaWRpYW4nLCAncGx1Z2lucycsICdvYnNpZGlhbi1zaW1pbGFyaXR5LXRvb2xraXQnLCAnUHl0aG9uJywgJ3Rva2VuaXplci5weScpO1xuXHRcblx0XHQvLyBBdHRlbXB0IHRvIHJlYWQgdGhlIENTViB0byBkZXRlcm1pbmUgaWYgaXQgZXhpc3RzXG5cdFx0bGV0IG5vdGljZTtcblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKGNzdlBhdGgpO1xuXHRcdFx0bm90aWNlID0gbmV3IE5vdGljZShcIlZhdWx0IGVtYmVkZGluZ3Mgd2lsbCBiZSB1cGRhdGVkXCIpOyBcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0bm90aWNlID0gbmV3IE5vdGljZShcIkNyZWF0aW5nIGluaXRpYWwgZW1iZWRkaW5ncyBmb3IgdmF1bHRcIiwgNjAwMDAwKTtcblx0XHR9XG5cdFxuXHRcdGNvbnN0IHByb2Nlc3MgPSBzcGF3bihweXRob25FeGVjdXRhYmxlLCBbc2NyaXB0UGF0aCwgYmFzZVBhdGhdKTtcblx0XG5cdFx0bGV0IGNzdkNvbnRlbnQgPSAnJztcblx0XHRwcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG5cdFx0XHRjc3ZDb250ZW50ICs9IGRhdGEudG9TdHJpbmcoKTtcblx0XHR9KTtcblx0XG5cdFx0cHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuXHRcdFx0Y29uc29sZS5lcnJvcihgc3RkZXJyOiAke2RhdGF9YCk7XG5cdFx0fSk7XG5cdFxuXHRcdHByb2Nlc3Mub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcblx0XHRcdGlmIChjb2RlICE9PSAwKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoYFByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0Vycm9yIHJ1bm5pbmcgdG9rZW5pemVyIHNjcmlwdC4nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNzdkNvbnRlbnQgPSBjc3ZDb250ZW50LnRyaW0oKTtcblx0XHRcdFx0Y29uc3QgbGluZXMgPSBjc3ZDb250ZW50LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAhPT0gJycpO1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkQ3N2Q29udGVudCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuXHRcblx0XHRcdFx0dGhpcy5hcHAudmF1bHQuYWRhcHRlci53cml0ZShjc3ZQYXRoLCB1cGRhdGVkQ3N2Q29udGVudCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJWYXVsdCBlbWJlZGRpbmdzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1ZhdWx0IGVtYmVkZGluZ3MgdXBkYXRlZCBzdWNjZXNzZnVsbHkuJyk7XG5cdFx0XHRcdFx0Ly8gUHJvY2VzcyBlYWNoIGZpbGUgaW4gdGhlIHJlbG9hZCBidWZmZXJcblx0XHRcdFx0XHR0aGlzLnJlbG9hZEJ1ZmZlci5mb3JFYWNoKGZpbGVQYXRoID0+IHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlU2luZ2xlRmlsZShmaWxlUGF0aCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0dGhpcy5yZWxvYWRCdWZmZXIuY2xlYXIoKTsgIC8vIENsZWFycyB0aGUgYnVmZmVyIGFmdGVyIHByb2Nlc3Npbmdcblx0XHRcdFx0fSkuY2F0Y2goKHdyaXRlRXJyb3IpID0+IHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBFcnJvciB3cml0aW5nIGVtYmVkZGluZ3MgZmlsZTogJHt3cml0ZUVycm9yfWApO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYEVycm9yIHdyaXRpbmcgZW1iZWRkaW5ncyBmaWxlOiAke3dyaXRlRXJyb3J9YCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIENvcnJlY3QgbWV0aG9kIHRvIGhpZGUgdGhlIG5vdGljZVxuXHRcdFx0bm90aWNlLmhpZGUoKTtcblx0XHR9KTtcblx0fVxuXG5cdGFzeW5jIHJ1bkdyYXBoVHNuZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRsZXQgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG5cdFx0bGV0IGJhc2VQYXRoID0gJyc7XG5cdFx0aWYgKGFkYXB0ZXIgaW5zdGFuY2VvZiBGaWxlU3lzdGVtQWRhcHRlcikge1xuXHRcdFx0YmFzZVBhdGggPSBhZGFwdGVyLmdldEJhc2VQYXRoKCk7XG5cdFx0fVxuXHRcblx0XHRjb25zdCBlbnZQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCAnLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ1B5dGhvbicsICdvYnNpZGlhbnNpbWlsYXJpdHknKTtcblx0XHRjb25zdCBzY3JpcHRQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCAnLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ1B5dGhvbicsICdzbmUtdG8tZGF0YS5weScpO1xuXHRcdGNvbnN0IGNzdlBhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsICcub2JzaWRpYW4nLCAncGx1Z2lucycsICdvYnNpZGlhbi1zaW1pbGFyaXR5LXRvb2xraXQnLCAnZW1iZWRkaW5ncy5jc3YnKTtcblx0XG5cdFx0Y29uc3QgcHl0aG9uRXhlY3V0YWJsZSA9IHBhdGguam9pbihlbnZQYXRoLCBuYXZpZ2F0b3IucGxhdGZvcm0uc3RhcnRzV2l0aCgnV2luJykgPyAnU2NyaXB0c1xcXFxweXRob24uZXhlJyA6ICdiaW4vcHl0aG9uMycpO1xuXHRcblx0XHRjb25zdCBwcm9jZXNzID0gc3Bhd24ocHl0aG9uRXhlY3V0YWJsZSwgW3NjcmlwdFBhdGgsIGNzdlBhdGhdKTtcblx0XG5cdFx0bGV0IG91dHB1dCA9ICcnO1xuXHRcdHByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcblx0XHRcdG91dHB1dCArPSBkYXRhLnRvU3RyaW5nKCk7XG5cdFx0fSk7XG5cdFxuXHRcdHByb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYHN0ZGVycjogJHtkYXRhfWApO1xuXHRcdH0pO1xuXHRcblx0XHRyZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0cHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuXHRcdFx0XHRpZiAoY29kZSAhPT0gMCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoYFByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRXJyb3IgcnVubmluZyBULVNORSBzY3JpcHQuJyk7XG5cdFx0XHRcdFx0cmVqZWN0KGBQcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dCk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLm5vZGVQb3NpdGlvbnMgPSByZXN1bHQubm9kZVBvc2l0aW9ucztcblx0XHRcdFx0XHRcdHRoaXMuc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdOb2RlIHBvc2l0aW9ucyB1cGRhdGVkIGFjY29yZGluZyB0byBULVNORScpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpOyAgLy8gRXhwbGljaXRseSByZXNvbHZpbmcgd2l0aCBubyB2YWx1ZSwgZXJyb3IgaWYgbm90XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBvdXRwdXQ6JywgZXJyb3IpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIHVwZGF0ZSBub2RlIHBvc2l0aW9ucy4nKTtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdGFzeW5jIHVwZGF0ZVNpbmdsZUZpbGUoZmlsZVBhdGg6IHN0cmluZykge1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXHRcdGxldCBiYXNlUGF0aCA9ICcnO1xuXHRcdGlmIChhZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcblx0XHRcdGJhc2VQYXRoID0gYWRhcHRlci5nZXRCYXNlUGF0aCgpO1xuXHRcdH1cblx0XG5cdFx0Y29uc3QgYWJzb2x1dGVGaWxlUGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgZmlsZVBhdGgpO1xuXHRcblx0XHRjb25zdCBzY3JpcHRQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCAnLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ1B5dGhvbicsICd0b2tlbml6ZXIucHknKTtcblx0XG5cdFx0Ly8gU3Bhd24gdGhlIFB5dGhvbiBwcm9jZXNzIHdpdGggdGhlIGFic29sdXRlIGZpbGUgcGF0aFxuXHRcdGNvbnN0IHByb2Nlc3MgPSBzcGF3bih0aGlzLnB5dGhvbkNvbW1hbmQsIFtzY3JpcHRQYXRoLCBhYnNvbHV0ZUZpbGVQYXRoXSk7XG5cdFxuXHRcdHByb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYHN0ZGVycjogJHtkYXRhfWApO1xuXHRcdH0pO1xuXHRcblx0XHRwcm9jZXNzLm9uKCdjbG9zZScsIGFzeW5jIChjb2RlKSA9PiB7XG5cdFx0XHRpZiAoY29kZSAhPT0gMCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGBQcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWApO1xuXHRcdFx0XHRuZXcgTm90aWNlKCdFcnJvciB1cGRhdGluZyBlbWJlZGRpbmcuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHRsZXQgbmV3RW1iZWRkaW5nID0gJyc7XG5cdFx0XHRwcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG5cdFx0XHRcdG5ld0VtYmVkZGluZyArPSBkYXRhLnRvU3RyaW5nKCk7XG5cdFx0XHR9KTtcblx0XG5cdFx0XHQvLyBSZWFkIHRoZSBjdXJyZW50IENTViwgdXBkYXRlIGl0LCBhbmQgd3JpdGUgYmFja1xuXHRcdFx0Y29uc3QgY3N2UGF0aCA9IHBhdGguam9pbignLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ2VtYmVkZGluZ3MuY3N2Jyk7XG5cdFx0XHRsZXQgY3N2Q29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChjc3ZQYXRoKTtcblx0XHRcdGxldCBsaW5lcyA9IGNzdkNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuXHRcdFx0Y29uc3QgaW5kZXggPSBsaW5lcy5maW5kSW5kZXgobGluZSA9PiBsaW5lLnN0YXJ0c1dpdGgoZmlsZVBhdGggKyAnLCcpKTtcblx0XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGxpbmVzLnNwbGljZShpbmRleCwgMSk7ICAvLyBSZW1vdmUgdGhlIG9sZCBlbWJlZGRpbmdcblx0XHRcdH1cblx0XHRcdGxpbmVzLnB1c2gobmV3RW1iZWRkaW5nLnRyaW0oKSk7IFxuXHRcblx0XHRcdGNvbnN0IHVwZGF0ZWRDc3ZDb250ZW50ID0gbGluZXMuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKS5qb2luKCdcXG4nKTtcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIud3JpdGUoY3N2UGF0aCwgdXBkYXRlZENzdkNvbnRlbnQpO1xuXHRcdFx0Y29uc29sZS5sb2coYFVwZGF0ZWQgZW1iZWRkaW5ncyBmb3IgJHtmaWxlUGF0aH1gKTtcblx0XHR9KTtcblx0fVxuXHRcbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUF5RjtBQUN6RiwyQkFBNEI7QUFDNUIsV0FBc0I7QUFDdEIsZ0JBQStCO0FBWS9CLElBQU0sbUJBQXFDO0FBQUEsRUFDdkMsZUFBZSxDQUFDO0FBQ3BCO0FBRUEsSUFBcUIsV0FBckIsY0FBc0MsdUJBQU87QUFBQSxFQUE3QztBQUFBO0FBR0kseUJBQTZCLG9CQUFJLElBQUk7QUFDckMsd0JBQTRCLG9CQUFJLElBQUk7QUFDcEMsMkJBQStDLG9CQUFJLElBQUk7QUFBQTtBQUFBLEVBRXZELE1BQU0sU0FBUztBQUNYLFNBQUssaUJBQWlCO0FBQ3RCLFVBQU0sS0FBSyxhQUFhO0FBQ3hCLFNBQUssWUFBWTtBQUNqQixVQUFNLEtBQUssd0JBQXdCO0FBQ25DLFVBQU0sS0FBSyx5QkFBeUI7QUFHcEMsU0FBSztBQUFBLE1BQ0QsS0FBSyxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsU0FBUztBQUNsQyxZQUFJLGdCQUFnQix1QkFBTztBQUN2QixrQkFBUSxJQUFJLGtCQUFrQixLQUFLLE1BQU07QUFDekMsZUFBSyxtQkFBbUIsS0FBSyxJQUFJO0FBQ2pDLGVBQUssa0JBQWtCLEtBQUssSUFBSTtBQUFBLFFBQ3BDO0FBQUEsTUFDSixDQUFDO0FBQUEs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
