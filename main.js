/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var path = __toESM(require("path"));
var import_fs = require("fs");
var DEFAULT_SETTINGS = {
  nodePositions: []
};
var MyPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.ongoingBuffer = /* @__PURE__ */ new Set();
    this.reloadBuffer = /* @__PURE__ */ new Set();
    this.ongoingTimeouts = /* @__PURE__ */ new Map();
  }
  async onload() {
    this.setPythonCommand();
    await this.loadSettings();
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.addCommands();
    await this.checkPythonRequirements();
    await this.runTokenizerScriptOnLoad();
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian.TFile) {
          console.log(`File modified: ${file.path}`);
          this.addToOngoingBuffer(file.path);
          this.addToReloadBuffer(file.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile) {
          console.log(`File moved or renamed from ${oldPath} to ${file.path}`);
          this.addToOngoingBuffer(file.path);
          this.addToReloadBuffer(file.path);
        }
      })
    );
  }
  addToOngoingBuffer(filePath) {
    if (!this.ongoingBuffer.has(filePath)) {
      this.ongoingBuffer.add(filePath);
      const timeout = setTimeout(() => {
        this.updateSingleFile(filePath);
        this.ongoingBuffer.delete(filePath);
        this.ongoingTimeouts.delete(filePath);
      }, 1e4);
      this.ongoingTimeouts.set(filePath, timeout);
    }
  }
  addToReloadBuffer(filePath) {
    if (!this.reloadBuffer.has(filePath)) {
      this.reloadBuffer.add(filePath);
    }
  }
  async runTokenizerScriptOnLoad() {
    const adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const envPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "obsidiansimilarity");
    const flagPath = path.join(envPath, "setup_complete.flag");
    try {
      await import_fs.promises.access(flagPath);
      await this.runTokenizerScript();
    } catch (error) {
      console.error("Tokenizer script cannot run: Environment setup is not complete.");
      new import_obsidian.Notice("Tokenizer script cannot run: Please ensure all packages are installed.");
    }
  }
  setPythonCommand() {
    this.pythonCommand = navigator.platform.startsWith("Win") ? "python" : "python3";
    console.log("Using Python command:", this.pythonCommand);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async checkPythonRequirements() {
    const adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const envPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "obsidiansimilarity");
    const requirementsPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "requirements.txt");
    const flagPath = path.join(envPath, "setup_complete.flag");
    try {
      await import_fs.promises.access(flagPath);
      console.log("Environment setup is already complete.");
      return;
    } catch (error) {
      console.log("Environment setup is not complete. Starting setup...");
    }
    const notice = new import_obsidian.Notice("Setting up Python environment for Obsidian Similarity Toolkit. Please wait...", 6e5);
    let environmentCreated = false;
    try {
      await import_fs.promises.stat(envPath);
      console.log("Virtual environment already exists.");
    } catch (error) {
      if (error.code === "ENOENT") {
        console.log("Virtual environment not found, attempting to create one...");
        try {
          const createEnvProcess = (0, import_child_process.spawn)(this.pythonCommand, ["-m", "venv", envPath]);
          await new Promise((resolve, reject) => {
            createEnvProcess.on("close", (code) => {
              if (code === 0) {
                console.log("Virtual environment created successfully.");
                new import_obsidian.Notice("Environment folder succesfully created.");
                environmentCreated = true;
                resolve(code);
              } else {
                console.error(`Failed to create virtual environment with exit code: ${code}`);
                new import_obsidian.Notice("Failed to create virtual environment. Please check your Python installation.");
                reject(new Error(`Failed to create virtual environment with code ${code}`));
              }
            });
          });
        } catch (error2) {
          console.error("Error during virtual environment creation:", error2);
          new import_obsidian.Notice("Failed to create virtual environment. Please check your Python installation.");
          return;
        }
      } else {
        console.error("Error checking virtual environment:", error);
        new import_obsidian.Notice("Error checking virtual environment. Please check your permissions and file system.");
        return;
      }
    }
    if (environmentCreated) {
      let pythonExecutable = path.join(envPath, navigator.platform.startsWith("Win") ? "Scripts\\python.exe" : "bin/python3");
      const installCmd = (0, import_child_process.spawn)(pythonExecutable, ["-m", "pip", "install", "-r", requirementsPath]);
      installCmd.stdout.on("data", (data) => {
        console.log(data.toString());
      });
      installCmd.stderr.on("data", (data) => {
        const errorOutput = data.toString();
        console.error(`stderr: ${errorOutput}`);
        new import_obsidian.Notice(`Error during package installation: ${errorOutput}`);
      });
      await new Promise((resolve, reject) => {
        installCmd.on("close", (code) => {
          if (code === 0) {
            console.log("All packages installed successfully.");
            new import_obsidian.Notice("All packages installed successfully.");
            resolve();
          } else {
            console.error(`Failed to install packages with code ${code}`);
            new import_obsidian.Notice(`Failed to install packages. Please check the installation logs.`);
            reject(new Error(`Failed to install packages with code ${code}`));
          }
        });
      });
      try {
        await import_fs.promises.writeFile(path.join(envPath, "setup_complete.flag"), "Setup complete");
        new import_obsidian.Notice("Environment setup is complete.");
        setTimeout(() => notice.hide(), 1e3);
      } catch (error) {
        console.error("Failed to create setup complete flag file:", error);
        new import_obsidian.Notice("Failed to create setup complete flag file. Please check your permissions and file system.");
      }
    } else {
      console.log("Skipping package installation as the virtual environment already exists.");
    }
  }
  addCommands() {
    this.addCommand({
      id: "similarity-graph-position",
      name: "Organize graph with similarity",
      callback: async () => {
        const notice = new import_obsidian.Notice("Organizing graph based on similarity...", 6e4);
        console.log("Attempting to run T-SNE and restore node positions...");
        await this.runGraphTsne();
        const graphLeaf = this.findGraphLeaf();
        if (graphLeaf) {
          console.log("Graph leaf found, restoring data...");
          this.restoreGraphData(graphLeaf);
        } else {
          console.log("No graph leaf found or multiple leaves present.");
          new import_obsidian.Notice("Graph view must be singular and active");
        }
        notice.hide();
      }
    });
    this.addCommand({
      id: "manual-run-embeddings",
      name: "Manually re-calculate embeddings",
      callback: () => this.runTokenizerScript()
    });
    this.addCommand({
      id: "update-single-file",
      name: "Update embedding for current file",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian.Notice("No file is currently active.");
          return;
        }
        this.updateSingleFile(activeFile.path);
      }
    });
  }
  findGraphLeaf() {
    let graphLeaves = this.app.workspace.getLeavesOfType("graph");
    console.log(`Found ${graphLeaves.length} graph leaves.`);
    if (graphLeaves.length === 1) {
      return graphLeaves[0];
    }
    return null;
  }
  restoreGraphData(graphLeaf) {
    if (!graphLeaf) {
      console.log("No graph leaf provided to restoreGraphData.");
      return;
    }
    const nodePositions = this.settings.nodePositions;
    if (nodePositions.length === 0) {
      console.log("No node positions available in settings.");
      return;
    }
    nodePositions.forEach((node) => {
      console.log(`Restoring position for node ${node.id}: (${node.x}, ${node.y})`);
      graphLeaf.view.renderer.worker.postMessage({
        forceNode: {
          id: node.id,
          x: node.x,
          y: node.y
        }
      });
    });
    graphLeaf.view.renderer.worker.postMessage({
      run: true,
      alpha: 0.1
    });
    console.log("Redraw triggered.");
  }
  async runTokenizerScript() {
    let adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const envPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "obsidiansimilarity");
    const flagPath = path.join(envPath, "setup_complete.flag");
    const csvPath = path.join(".obsidian", "plugins", "obsidian-similarity-toolkit", "embeddings.csv");
    try {
      await import_fs.promises.access(flagPath);
    } catch (error) {
      console.error("Environment setup is not complete. Please ensure all packages are installed.");
      new import_obsidian.Notice("Environment setup is not complete. Please ensure all packages are installed.");
      return;
    }
    const pythonExecutable = path.join(envPath, navigator.platform.startsWith("Win") ? "Scripts\\python.exe" : "bin/python3");
    const scriptPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "tokenizer.py");
    let notice;
    try {
      await this.app.vault.adapter.read(csvPath);
      notice = new import_obsidian.Notice("Vault embeddings will be updated");
    } catch (error) {
      notice = new import_obsidian.Notice("Creating initial embeddings for vault", 6e5);
    }
    const process = (0, import_child_process.spawn)(pythonExecutable, [scriptPath, basePath]);
    let csvContent = "";
    process.stdout.on("data", (data) => {
      csvContent += data.toString();
    });
    process.stderr.on("data", (data) => {
      console.error(`stderr: ${data}`);
    });
    process.on("close", (code) => {
      if (code !== 0) {
        console.error(`Process exited with code ${code}`);
        new import_obsidian.Notice("Error running tokenizer script.");
      } else {
        csvContent = csvContent.trim();
        const lines = csvContent.split("\n").filter((line) => line.trim() !== "");
        const updatedCsvContent = lines.join("\n");
        this.app.vault.adapter.write(csvPath, updatedCsvContent).then(() => {
          console.log("Vault embeddings updated successfully");
          new import_obsidian.Notice("Vault embeddings updated successfully.");
          this.reloadBuffer.forEach((filePath) => {
            this.updateSingleFile(filePath);
          });
          this.reloadBuffer.clear();
        }).catch((writeError) => {
          console.error(`Error writing embeddings file: ${writeError}`);
          new import_obsidian.Notice(`Error writing embeddings file: ${writeError}`);
        });
      }
      notice.hide();
    });
  }
  async runGraphTsne() {
    let adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const envPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "obsidiansimilarity");
    const scriptPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "sne-to-data.py");
    const csvPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "embeddings.csv");
    const pythonExecutable = path.join(envPath, navigator.platform.startsWith("Win") ? "Scripts\\python.exe" : "bin/python3");
    const process = (0, import_child_process.spawn)(pythonExecutable, [scriptPath, csvPath]);
    let output = "";
    process.stdout.on("data", (data) => {
      output += data.toString();
    });
    process.stderr.on("data", (data) => {
      console.error(`stderr: ${data}`);
    });
    return new Promise((resolve, reject) => {
      process.on("close", (code) => {
        if (code !== 0) {
          console.error(`Process exited with code ${code}`);
          new import_obsidian.Notice("Error running T-SNE script.");
          reject(`Process exited with code ${code}`);
        } else {
          try {
            const result = JSON.parse(output);
            this.settings.nodePositions = result.nodePositions;
            this.saveSettings();
            new import_obsidian.Notice("Node positions updated according to T-SNE");
            resolve();
          } catch (error) {
            console.error("Failed to parse output:", error);
            new import_obsidian.Notice("Failed to update node positions.");
            reject(error);
          }
        }
      });
    });
  }
  async updateSingleFile(filePath) {
    const adapter = this.app.vault.adapter;
    let basePath = "";
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    const absoluteFilePath = path.join(basePath, filePath);
    const scriptPath = path.join(basePath, ".obsidian", "plugins", "obsidian-similarity-toolkit", "Python", "tokenizer.py");
    const process = (0, import_child_process.spawn)(this.pythonCommand, [scriptPath, absoluteFilePath]);
    process.stderr.on("data", (data) => {
      console.error(`stderr: ${data}`);
    });
    process.on("close", async (code) => {
      if (code !== 0) {
        console.error(`Process exited with code ${code}`);
        new import_obsidian.Notice("Error updating embedding.");
        return;
      }
      let newEmbedding = "";
      process.stdout.on("data", (data) => {
        newEmbedding += data.toString();
      });
      const csvPath = path.join(".obsidian", "plugins", "obsidian-similarity-toolkit", "embeddings.csv");
      let csvContent = await this.app.vault.adapter.read(csvPath);
      let lines = csvContent.split("\n");
      const index = lines.findIndex((line) => line.startsWith(filePath + ","));
      if (index !== -1) {
        lines.splice(index, 1);
      }
      lines.push(newEmbedding.trim());
      const updatedCsvContent = lines.filter((line) => line.trim() !== "").join("\n");
      await this.app.vault.adapter.write(csvPath, updatedCsvContent);
      console.log(`Updated embeddings for ${filePath}`);
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIEZpbGVTeXN0ZW1BZGFwdGVyLCBOb3RpY2UsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgZXhlYywgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcblxuaW50ZXJmYWNlIE5vZGVQb3NpdGlvbiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XG4gICAgbm9kZVBvc2l0aW9uczogTm9kZVBvc2l0aW9uW107XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE15UGx1Z2luU2V0dGluZ3MgPSB7XG4gICAgbm9kZVBvc2l0aW9uczogW10sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncztcbiAgICBweXRob25Db21tYW5kOiBzdHJpbmc7XG4gICAgb25nb2luZ0J1ZmZlcjogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gICAgcmVsb2FkQnVmZmVyOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgICBvbmdvaW5nVGltZW91dHM6IE1hcDxzdHJpbmcsIE5vZGVKUy5UaW1lb3V0PiA9IG5ldyBNYXAoKTtcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgdGhpcy5zZXRQeXRob25Db21tYW5kKCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2FtcGxlU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgICAgICB0aGlzLmFkZENvbW1hbmRzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tQeXRob25SZXF1aXJlbWVudHMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5Ub2tlbml6ZXJTY3JpcHRPbkxvYWQoKTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIGZpbGUgbW9kaWZpY2F0aW9uc1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5vbignbW9kaWZ5JywgKGZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGaWxlIG1vZGlmaWVkOiAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb09uZ29pbmdCdWZmZXIoZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb1JlbG9hZEJ1ZmZlcihmaWxlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBmaWxlIHJlbmFtZXMgYW5kIG1vdmVzXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKCdyZW5hbWUnLCAoZmlsZSwgb2xkUGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZpbGUgbW92ZWQgb3IgcmVuYW1lZCBmcm9tICR7b2xkUGF0aH0gdG8gJHtmaWxlLnBhdGh9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9PbmdvaW5nQnVmZmVyKGZpbGUucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9SZWxvYWRCdWZmZXIoZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGFkZFRvT25nb2luZ0J1ZmZlcihmaWxlUGF0aDogc3RyaW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmdvaW5nQnVmZmVyLmhhcyhmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMub25nb2luZ0J1ZmZlci5hZGQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2luZ2xlRmlsZShmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmdvaW5nQnVmZmVyLmRlbGV0ZShmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmdvaW5nVGltZW91dHMuZGVsZXRlKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIH0sIDEwMDAwKTsgIC8vIDEwIHNlY29uZHMgZGVsYXlcbiAgICAgICAgICAgIHRoaXMub25nb2luZ1RpbWVvdXRzLnNldChmaWxlUGF0aCwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRUb1JlbG9hZEJ1ZmZlcihmaWxlUGF0aDogc3RyaW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWxvYWRCdWZmZXIuaGFzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRCdWZmZXIuYWRkKGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHJ1blRva2VuaXplclNjcmlwdE9uTG9hZCgpIHtcbiAgICAgICAgY29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG4gICAgICAgIGxldCBiYXNlUGF0aCA9ICcnO1xuICAgICAgICBpZiAoYWRhcHRlciBpbnN0YW5jZW9mIEZpbGVTeXN0ZW1BZGFwdGVyKSB7XG4gICAgICAgICAgICBiYXNlUGF0aCA9IGFkYXB0ZXIuZ2V0QmFzZVBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVudlBhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsICcub2JzaWRpYW4nLCAncGx1Z2lucycsICdvYnNpZGlhbi1zaW1pbGFyaXR5LXRvb2xraXQnLCAnUHl0aG9uJywgJ29ic2lkaWFuc2ltaWxhcml0eScpO1xuICAgICAgICBjb25zdCBmbGFnUGF0aCA9IHBhdGguam9pbihlbnZQYXRoLCAnc2V0dXBfY29tcGxldGUuZmxhZycpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmcy5hY2Nlc3MoZmxhZ1BhdGgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5Ub2tlbml6ZXJTY3JpcHQoKTsgIC8vIFJ1biB0b2tlbml6ZXIgc2NyaXB0IGlmIHNldHVwIGlzIGNvbXBsZXRlXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVG9rZW5pemVyIHNjcmlwdCBjYW5ub3QgcnVuOiBFbnZpcm9ubWVudCBzZXR1cCBpcyBub3QgY29tcGxldGUuXCIpO1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlRva2VuaXplciBzY3JpcHQgY2Fubm90IHJ1bjogUGxlYXNlIGVuc3VyZSBhbGwgcGFja2FnZXMgYXJlIGluc3RhbGxlZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cblx0c2V0UHl0aG9uQ29tbWFuZCgpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBQeXRob24gY29tbWFuZCBiYXNlZCBvbiB0aGUgcGxhdGZvcm1cbiAgICAgICAgdGhpcy5weXRob25Db21tYW5kID0gbmF2aWdhdG9yLnBsYXRmb3JtLnN0YXJ0c1dpdGgoJ1dpbicpID8gJ3B5dGhvbicgOiAncHl0aG9uMyc7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgUHl0aG9uIGNvbW1hbmQ6XCIsIHRoaXMucHl0aG9uQ29tbWFuZCk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG5cdGFzeW5jIGNoZWNrUHl0aG9uUmVxdWlyZW1lbnRzKCkge1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXHRcdGxldCBiYXNlUGF0aCA9ICcnO1xuXHRcdGlmIChhZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcblx0XHRcdGJhc2VQYXRoID0gYWRhcHRlci5nZXRCYXNlUGF0aCgpO1xuXHRcdH1cblx0XG5cdFx0Y29uc3QgZW52UGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgJy5vYnNpZGlhbicsICdwbHVnaW5zJywgJ29ic2lkaWFuLXNpbWlsYXJpdHktdG9vbGtpdCcsICdQeXRob24nLCAnb2JzaWRpYW5zaW1pbGFyaXR5Jyk7XG5cdFx0Y29uc3QgcmVxdWlyZW1lbnRzUGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgJy5vYnNpZGlhbicsICdwbHVnaW5zJywgJ29ic2lkaWFuLXNpbWlsYXJpdHktdG9vbGtpdCcsICdQeXRob24nLCAncmVxdWlyZW1lbnRzLnR4dCcpO1xuXHRcdGNvbnN0IGZsYWdQYXRoID0gcGF0aC5qb2luKGVudlBhdGgsICdzZXR1cF9jb21wbGV0ZS5mbGFnJyk7XG5cdFxuXHRcdC8vIENoZWNrIGlmIHRoZSBzZXR1cCBjb21wbGV0ZSBmbGFnIGV4aXN0c1xuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBmcy5hY2Nlc3MoZmxhZ1BhdGgpO1xuXHRcdFx0Y29uc29sZS5sb2coXCJFbnZpcm9ubWVudCBzZXR1cCBpcyBhbHJlYWR5IGNvbXBsZXRlLlwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5sb2coXCJFbnZpcm9ubWVudCBzZXR1cCBpcyBub3QgY29tcGxldGUuIFN0YXJ0aW5nIHNldHVwLi4uXCIpO1xuXHRcdH1cblxuXHRcdC8vIENyZWF0aW5nIGEgbm90aWNlIHdpdGggYSBkdXJhdGlvbiBvZiAxMCBtaW51dGVzICg2MDAwMDAgbWlsbGlzZWNvbmRzKVxuXHRcdGNvbnN0IG5vdGljZSA9IG5ldyBOb3RpY2UoXCJTZXR0aW5nIHVwIFB5dGhvbiBlbnZpcm9ubWVudCBmb3IgT2JzaWRpYW4gU2ltaWxhcml0eSBUb29sa2l0LiBQbGVhc2Ugd2FpdC4uLlwiLCA2MDAwMDApO1xuXG5cdFx0bGV0IGVudmlyb25tZW50Q3JlYXRlZCA9IGZhbHNlO1xuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBmcy5zdGF0KGVudlBhdGgpO1xuXHRcdFx0Y29uc29sZS5sb2coXCJWaXJ0dWFsIGVudmlyb25tZW50IGFscmVhZHkgZXhpc3RzLlwiKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiVmlydHVhbCBlbnZpcm9ubWVudCBub3QgZm91bmQsIGF0dGVtcHRpbmcgdG8gY3JlYXRlIG9uZS4uLlwiKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCBjcmVhdGVFbnZQcm9jZXNzID0gc3Bhd24odGhpcy5weXRob25Db21tYW5kLCBbJy1tJywgJ3ZlbnYnLCBlbnZQYXRoXSk7XG5cdFx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0XHRcdFx0Y3JlYXRlRW52UHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoY29kZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiVmlydHVhbCBlbnZpcm9ubWVudCBjcmVhdGVkIHN1Y2Nlc3NmdWxseS5cIik7XG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIkVudmlyb25tZW50IGZvbGRlciBzdWNjZXNmdWxseSBjcmVhdGVkLlwiKTtcblx0XHRcdFx0XHRcdFx0XHRlbnZpcm9ubWVudENyZWF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoY29kZSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB2aXJ0dWFsIGVudmlyb25tZW50IHdpdGggZXhpdCBjb2RlOiAke2NvZGV9YCk7XG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIkZhaWxlZCB0byBjcmVhdGUgdmlydHVhbCBlbnZpcm9ubWVudC4gUGxlYXNlIGNoZWNrIHlvdXIgUHl0aG9uIGluc3RhbGxhdGlvbi5cIik7XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB2aXJ0dWFsIGVudmlyb25tZW50IHdpdGggY29kZSAke2NvZGV9YCkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHZpcnR1YWwgZW52aXJvbm1lbnQgY3JlYXRpb246XCIsIGVycm9yKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiRmFpbGVkIHRvIGNyZWF0ZSB2aXJ0dWFsIGVudmlyb25tZW50LiBQbGVhc2UgY2hlY2sgeW91ciBQeXRob24gaW5zdGFsbGF0aW9uLlwiKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyB2aXJ0dWFsIGVudmlyb25tZW50OlwiLCBlcnJvcik7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJFcnJvciBjaGVja2luZyB2aXJ0dWFsIGVudmlyb25tZW50LiBQbGVhc2UgY2hlY2sgeW91ciBwZXJtaXNzaW9ucyBhbmQgZmlsZSBzeXN0ZW0uXCIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRpZiAoZW52aXJvbm1lbnRDcmVhdGVkKSB7XG5cdFx0XHRsZXQgcHl0aG9uRXhlY3V0YWJsZSA9IHBhdGguam9pbihlbnZQYXRoLCBuYXZpZ2F0b3IucGxhdGZvcm0uc3RhcnRzV2l0aCgnV2luJykgPyAnU2NyaXB0c1xcXFxweXRob24uZXhlJyA6ICdiaW4vcHl0aG9uMycpO1xuXHRcdFx0Y29uc3QgaW5zdGFsbENtZCA9IHNwYXduKHB5dGhvbkV4ZWN1dGFibGUsIFsnLW0nLCAncGlwJywgJ2luc3RhbGwnLCAnLXInLCByZXF1aXJlbWVudHNQYXRoXSk7XG5cdFxuXHRcdFx0aW5zdGFsbENtZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhkYXRhLnRvU3RyaW5nKCkpO1xuXHRcdFx0fSk7XG5cdFxuXHRcdFx0aW5zdGFsbENtZC5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuXHRcdFx0XHRjb25zdCBlcnJvck91dHB1dCA9IGRhdGEudG9TdHJpbmcoKTtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihgc3RkZXJyOiAke2Vycm9yT3V0cHV0fWApO1xuXHRcdFx0XHRuZXcgTm90aWNlKGBFcnJvciBkdXJpbmcgcGFja2FnZSBpbnN0YWxsYXRpb246ICR7ZXJyb3JPdXRwdXR9YCk7XG5cdFx0XHR9KTtcblx0XG5cdFx0XHRhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRcdGluc3RhbGxDbWQub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcblx0XHRcdFx0XHRpZiAoY29kZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJBbGwgcGFja2FnZXMgaW5zdGFsbGVkIHN1Y2Nlc3NmdWxseS5cIik7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiQWxsIHBhY2thZ2VzIGluc3RhbGxlZCBzdWNjZXNzZnVsbHkuXCIpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gaW5zdGFsbCBwYWNrYWdlcyB3aXRoIGNvZGUgJHtjb2RlfWApO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIGluc3RhbGwgcGFja2FnZXMuIFBsZWFzZSBjaGVjayB0aGUgaW5zdGFsbGF0aW9uIGxvZ3MuYCk7XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gaW5zdGFsbCBwYWNrYWdlcyB3aXRoIGNvZGUgJHtjb2RlfWApKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFxuXHRcdFx0Ly8gQWZ0ZXIgYWxsIHBhY2thZ2VzIGFyZSBpbnN0YWxsZWQgc3VjY2Vzc2Z1bGx5XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhd2FpdCBmcy53cml0ZUZpbGUocGF0aC5qb2luKGVudlBhdGgsICdzZXR1cF9jb21wbGV0ZS5mbGFnJyksICdTZXR1cCBjb21wbGV0ZScpO1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiRW52aXJvbm1lbnQgc2V0dXAgaXMgY29tcGxldGUuXCIpO1xuXHRcdFx0XHQvLyBIaWRlIHRoZSBub3RpY2UgYWZ0ZXIgMSBzZWNvbmQgKDEwMDAgbWlsbGlzZWNvbmRzKVxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IG5vdGljZS5oaWRlKCksIDEwMDApO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgc2V0dXAgY29tcGxldGUgZmxhZyBmaWxlOlwiLCBlcnJvcik7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJGYWlsZWQgdG8gY3JlYXRlIHNldHVwIGNvbXBsZXRlIGZsYWcgZmlsZS4gUGxlYXNlIGNoZWNrIHlvdXIgcGVybWlzc2lvbnMgYW5kIGZpbGUgc3lzdGVtLlwiKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coXCJTa2lwcGluZyBwYWNrYWdlIGluc3RhbGxhdGlvbiBhcyB0aGUgdmlydHVhbCBlbnZpcm9ubWVudCBhbHJlYWR5IGV4aXN0cy5cIik7XG5cdFx0fVxuXHR9XG5cblx0YWRkQ29tbWFuZHMoKSB7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdzaW1pbGFyaXR5LWdyYXBoLXBvc2l0aW9uJyxcblx0XHRcdG5hbWU6ICdPcmdhbml6ZSBncmFwaCB3aXRoIHNpbWlsYXJpdHknLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHsgIC8vIE1ha2UgdGhlIGNhbGxiYWNrIGFzeW5jIHRvIHVzZSBhd2FpdFxuXHRcdFx0XHRjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKFwiT3JnYW5pemluZyBncmFwaCBiYXNlZCBvbiBzaW1pbGFyaXR5Li4uXCIsIDYwMDAwKTsgLy8gTm90aWNlIHNob3duIGR1cmluZyB0aGUgb3BlcmF0aW9uIG9ubHlcblx0XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiQXR0ZW1wdGluZyB0byBydW4gVC1TTkUgYW5kIHJlc3RvcmUgbm9kZSBwb3NpdGlvbnMuLi5cIik7XG5cdFx0XHRcdGF3YWl0IHRoaXMucnVuR3JhcGhUc25lKCk7ICAvLyBBd2FpdHMgdGhlIGNvbXBsZXRpb24gb2YgVC1TTkUgcHJvY2Vzc2luZ1xuXHRcblx0XHRcdFx0Y29uc3QgZ3JhcGhMZWFmID0gdGhpcy5maW5kR3JhcGhMZWFmKCk7XG5cdFx0XHRcdGlmIChncmFwaExlYWYpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkdyYXBoIGxlYWYgZm91bmQsIHJlc3RvcmluZyBkYXRhLi4uXCIpO1xuXHRcdFx0XHRcdHRoaXMucmVzdG9yZUdyYXBoRGF0YShncmFwaExlYWYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiTm8gZ3JhcGggbGVhZiBmb3VuZCBvciBtdWx0aXBsZSBsZWF2ZXMgcHJlc2VudC5cIik7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnR3JhcGggdmlldyBtdXN0IGJlIHNpbmd1bGFyIGFuZCBhY3RpdmUnKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0bm90aWNlLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9KTsgXG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdtYW51YWwtcnVuLWVtYmVkZGluZ3MnLFxuXHRcdFx0bmFtZTogJ01hbnVhbGx5IHJlLWNhbGN1bGF0ZSBlbWJlZGRpbmdzJyxcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB0aGlzLnJ1blRva2VuaXplclNjcmlwdCgpXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICd1cGRhdGUtc2luZ2xlLWZpbGUnLFxuXHRcdFx0bmFtZTogJ1VwZGF0ZSBlbWJlZGRpbmcgZm9yIGN1cnJlbnQgZmlsZScsXG5cdFx0XHRjYWxsYmFjazogKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcblx0XHRcdFx0aWYgKCFhY3RpdmVGaWxlKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vIGZpbGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRlU2luZ2xlRmlsZShhY3RpdmVGaWxlLnBhdGgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuICAgIH1cblxuICAgIGZpbmRHcmFwaExlYWYoKTogYW55IHtcbiAgICAgICAgbGV0IGdyYXBoTGVhdmVzID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZSgnZ3JhcGgnKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7Z3JhcGhMZWF2ZXMubGVuZ3RofSBncmFwaCBsZWF2ZXMuYCk7XG4gICAgICAgIGlmIChncmFwaExlYXZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFwaExlYXZlc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXN0b3JlR3JhcGhEYXRhKGdyYXBoTGVhZjogYW55KSB7XG4gICAgICAgIGlmICghZ3JhcGhMZWFmKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGdyYXBoIGxlYWYgcHJvdmlkZWQgdG8gcmVzdG9yZUdyYXBoRGF0YS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlUG9zaXRpb25zOiBOb2RlUG9zaXRpb25bXSA9IHRoaXMuc2V0dGluZ3Mubm9kZVBvc2l0aW9ucztcbiAgICAgICAgaWYgKG5vZGVQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIG5vZGUgcG9zaXRpb25zIGF2YWlsYWJsZSBpbiBzZXR0aW5ncy5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlUG9zaXRpb25zLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXN0b3JpbmcgcG9zaXRpb24gZm9yIG5vZGUgJHtub2RlLmlkfTogKCR7bm9kZS54fSwgJHtub2RlLnl9KWApO1xuICAgICAgICAgICAgZ3JhcGhMZWFmLnZpZXcucmVuZGVyZXIud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBmb3JjZU5vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgICAgICAgICAgICAgeTogbm9kZS55XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvcmNlIGEgcmVkcmF3IGhlcmVcbiAgICAgICAgZ3JhcGhMZWFmLnZpZXcucmVuZGVyZXIud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHJ1bjogdHJ1ZSxcbiAgICAgICAgICAgIGFscGhhOiAwLjFcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVkcmF3IHRyaWdnZXJlZC5cIik7XG4gICAgfVxuXG5cdGFzeW5jIHJ1blRva2VuaXplclNjcmlwdCgpIHtcblx0XHRsZXQgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG5cdFx0bGV0IGJhc2VQYXRoID0gJyc7XG5cdFx0aWYgKGFkYXB0ZXIgaW5zdGFuY2VvZiBGaWxlU3lzdGVtQWRhcHRlcikge1xuXHRcdFx0YmFzZVBhdGggPSBhZGFwdGVyLmdldEJhc2VQYXRoKCk7XG5cdFx0fVxuXHRcblx0XHRjb25zdCBlbnZQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCAnLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ1B5dGhvbicsICdvYnNpZGlhbnNpbWlsYXJpdHknKTtcblx0XHRjb25zdCBmbGFnUGF0aCA9IHBhdGguam9pbihlbnZQYXRoLCAnc2V0dXBfY29tcGxldGUuZmxhZycpO1xuXHRcdGNvbnN0IGNzdlBhdGggPSBwYXRoLmpvaW4oJy5vYnNpZGlhbicsICdwbHVnaW5zJywgJ29ic2lkaWFuLXNpbWlsYXJpdHktdG9vbGtpdCcsICdlbWJlZGRpbmdzLmNzdicpOyAvLyBLZWVwIHRoZSBvcmlnaW5hbCBwYXRoIGFzIHJlcXVlc3RlZFxuXHRcblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgZnMuYWNjZXNzKGZsYWdQYXRoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVudmlyb25tZW50IHNldHVwIGlzIG5vdCBjb21wbGV0ZS4gUGxlYXNlIGVuc3VyZSBhbGwgcGFja2FnZXMgYXJlIGluc3RhbGxlZC5cIik7XG5cdFx0XHRuZXcgTm90aWNlKFwiRW52aXJvbm1lbnQgc2V0dXAgaXMgbm90IGNvbXBsZXRlLiBQbGVhc2UgZW5zdXJlIGFsbCBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkLlwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGNvbnN0IHB5dGhvbkV4ZWN1dGFibGUgPSBwYXRoLmpvaW4oZW52UGF0aCwgbmF2aWdhdG9yLnBsYXRmb3JtLnN0YXJ0c1dpdGgoJ1dpbicpID8gJ1NjcmlwdHNcXFxccHl0aG9uLmV4ZScgOiAnYmluL3B5dGhvbjMnKTtcblx0XHRjb25zdCBzY3JpcHRQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCAnLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ1B5dGhvbicsICd0b2tlbml6ZXIucHknKTtcblx0XG5cdFx0Ly8gQXR0ZW1wdCB0byByZWFkIHRoZSBDU1YgdG8gZGV0ZXJtaW5lIGlmIGl0IGV4aXN0c1xuXHRcdGxldCBub3RpY2U7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChjc3ZQYXRoKTtcblx0XHRcdG5vdGljZSA9IG5ldyBOb3RpY2UoXCJWYXVsdCBlbWJlZGRpbmdzIHdpbGwgYmUgdXBkYXRlZFwiKTsgXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdG5vdGljZSA9IG5ldyBOb3RpY2UoXCJDcmVhdGluZyBpbml0aWFsIGVtYmVkZGluZ3MgZm9yIHZhdWx0XCIsIDYwMDAwMCk7XG5cdFx0fVxuXHRcblx0XHRjb25zdCBwcm9jZXNzID0gc3Bhd24ocHl0aG9uRXhlY3V0YWJsZSwgW3NjcmlwdFBhdGgsIGJhc2VQYXRoXSk7XG5cdFxuXHRcdGxldCBjc3ZDb250ZW50ID0gJyc7XG5cdFx0cHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuXHRcdFx0Y3N2Q29udGVudCArPSBkYXRhLnRvU3RyaW5nKCk7XG5cdFx0fSk7XG5cdFxuXHRcdHByb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYHN0ZGVycjogJHtkYXRhfWApO1xuXHRcdH0pO1xuXHRcblx0XHRwcm9jZXNzLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG5cdFx0XHRpZiAoY29kZSAhPT0gMCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGBQcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWApO1xuXHRcdFx0XHRuZXcgTm90aWNlKCdFcnJvciBydW5uaW5nIHRva2VuaXplciBzY3JpcHQuJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjc3ZDb250ZW50ID0gY3N2Q29udGVudC50cmltKCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVzID0gY3N2Q29udGVudC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKTtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZENzdkNvbnRlbnQgPSBsaW5lcy5qb2luKCdcXG4nKTtcblx0XG5cdFx0XHRcdHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIud3JpdGUoY3N2UGF0aCwgdXBkYXRlZENzdkNvbnRlbnQpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiVmF1bHQgZW1iZWRkaW5ncyB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdWYXVsdCBlbWJlZGRpbmdzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5LicpO1xuXHRcdFx0XHRcdC8vIFByb2Nlc3MgZWFjaCBmaWxlIGluIHRoZSByZWxvYWQgYnVmZmVyXG5cdFx0XHRcdFx0dGhpcy5yZWxvYWRCdWZmZXIuZm9yRWFjaChmaWxlUGF0aCA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZVNpbmdsZUZpbGUoZmlsZVBhdGgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRoaXMucmVsb2FkQnVmZmVyLmNsZWFyKCk7ICAvLyBDbGVhcnMgdGhlIGJ1ZmZlciBhZnRlciBwcm9jZXNzaW5nXG5cdFx0XHRcdH0pLmNhdGNoKCh3cml0ZUVycm9yKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3Igd3JpdGluZyBlbWJlZGRpbmdzIGZpbGU6ICR7d3JpdGVFcnJvcn1gKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBFcnJvciB3cml0aW5nIGVtYmVkZGluZ3MgZmlsZTogJHt3cml0ZUVycm9yfWApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBDb3JyZWN0IG1ldGhvZCB0byBoaWRlIHRoZSBub3RpY2Vcblx0XHRcdG5vdGljZS5oaWRlKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRhc3luYyBydW5HcmFwaFRzbmUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0bGV0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXHRcdGxldCBiYXNlUGF0aCA9ICcnO1xuXHRcdGlmIChhZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcblx0XHRcdGJhc2VQYXRoID0gYWRhcHRlci5nZXRCYXNlUGF0aCgpO1xuXHRcdH1cblx0XG5cdFx0Y29uc3QgZW52UGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgJy5vYnNpZGlhbicsICdwbHVnaW5zJywgJ29ic2lkaWFuLXNpbWlsYXJpdHktdG9vbGtpdCcsICdQeXRob24nLCAnb2JzaWRpYW5zaW1pbGFyaXR5Jyk7XG5cdFx0Y29uc3Qgc2NyaXB0UGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgJy5vYnNpZGlhbicsICdwbHVnaW5zJywgJ29ic2lkaWFuLXNpbWlsYXJpdHktdG9vbGtpdCcsICdQeXRob24nLCAnc25lLXRvLWRhdGEucHknKTtcblx0XHRjb25zdCBjc3ZQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCAnLm9ic2lkaWFuJywgJ3BsdWdpbnMnLCAnb2JzaWRpYW4tc2ltaWxhcml0eS10b29sa2l0JywgJ2VtYmVkZGluZ3MuY3N2Jyk7XG5cdFxuXHRcdGNvbnN0IHB5dGhvbkV4ZWN1dGFibGUgPSBwYXRoLmpvaW4oZW52UGF0aCwgbmF2aWdhdG9yLnBsYXRmb3JtLnN0YXJ0c1dpdGgoJ1dpbicpID8gJ1NjcmlwdHNcXFxccHl0aG9uLmV4ZScgOiAnYmluL3B5dGhvbjMnKTtcblx0XG5cdFx0Y29uc3QgcHJvY2VzcyA9IHNwYXduKHB5dGhvbkV4ZWN1dGFibGUsIFtzY3JpcHRQYXRoLCBjc3ZQYXRoXSk7XG5cdFxuXHRcdGxldCBvdXRwdXQgPSAnJztcblx0XHRwcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG5cdFx0XHRvdXRwdXQgKz0gZGF0YS50b1N0cmluZygpO1xuXHRcdH0pO1xuXHRcblx0XHRwcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBzdGRlcnI6ICR7ZGF0YX1gKTtcblx0XHR9KTtcblx0XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHByb2Nlc3Mub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcblx0XHRcdFx0aWYgKGNvZGUgIT09IDApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBQcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWApO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0Vycm9yIHJ1bm5pbmcgVC1TTkUgc2NyaXB0LicpO1xuXHRcdFx0XHRcdHJlamVjdChgUHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5ub2RlUG9zaXRpb25zID0gcmVzdWx0Lm5vZGVQb3NpdGlvbnM7XG5cdFx0XHRcdFx0XHR0aGlzLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnTm9kZSBwb3NpdGlvbnMgdXBkYXRlZCBhY2NvcmRpbmcgdG8gVC1TTkUnKTtcblx0XHRcdFx0XHRcdHJlc29sdmUoKTsgIC8vIEV4cGxpY2l0bHkgcmVzb2x2aW5nIHdpdGggbm8gdmFsdWUsIGVycm9yIGlmIG5vdFxuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugb3V0cHV0OicsIGVycm9yKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byB1cGRhdGUgbm9kZSBwb3NpdGlvbnMuJyk7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHRhc3luYyB1cGRhdGVTaW5nbGVGaWxlKGZpbGVQYXRoOiBzdHJpbmcpIHtcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblx0XHRsZXQgYmFzZVBhdGggPSAnJztcblx0XHRpZiAoYWRhcHRlciBpbnN0YW5jZW9mIEZpbGVTeXN0ZW1BZGFwdGVyKSB7XG5cdFx0XHRiYXNlUGF0aCA9IGFkYXB0ZXIuZ2V0QmFzZVBhdGgoKTtcblx0XHR9XG5cdFxuXHRcdGNvbnN0IGFic29sdXRlRmlsZVBhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsIGZpbGVQYXRoKTtcblx0XG5cdFx0Y29uc3Qgc2NyaXB0UGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgJy5vYnNpZGlhbicsICdwbHVnaW5zJywgJ29ic2lkaWFuLXNpbWlsYXJpdHktdG9vbGtpdCcsICdQeXRob24nLCAndG9rZW5pemVyLnB5Jyk7XG5cdFxuXHRcdC8vIFNwYXduIHRoZSBQeXRob24gcHJvY2VzcyB3aXRoIHRoZSBhYnNvbHV0ZSBmaWxlIHBhdGhcblx0XHRjb25zdCBwcm9jZXNzID0gc3Bhd24odGhpcy5weXRob25Db21tYW5kLCBbc2NyaXB0UGF0aCwgYWJzb2x1dGVGaWxlUGF0aF0pO1xuXHRcblx0XHRwcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBzdGRlcnI6ICR7ZGF0YX1gKTtcblx0XHR9KTtcblx0XG5cdFx0cHJvY2Vzcy5vbignY2xvc2UnLCBhc3luYyAoY29kZSkgPT4ge1xuXHRcdFx0aWYgKGNvZGUgIT09IDApIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihgUHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnRXJyb3IgdXBkYXRpbmcgZW1iZWRkaW5nLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0bGV0IG5ld0VtYmVkZGluZyA9ICcnO1xuXHRcdFx0cHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuXHRcdFx0XHRuZXdFbWJlZGRpbmcgKz0gZGF0YS50b1N0cmluZygpO1xuXHRcdFx0fSk7XG5cdFxuXHRcdFx0Ly8gUmVhZCB0aGUgY3VycmVudCBDU1YsIHVwZGF0ZSBpdCwgYW5kIHdyaXRlIGJhY2tcblx0XHRcdGNvbnN0IGNzdlBhdGggPSBwYXRoLmpvaW4oJy5vYnNpZGlhbicsICdwbHVnaW5zJywgJ29ic2lkaWFuLXNpbWlsYXJpdHktdG9vbGtpdCcsICdlbWJlZGRpbmdzLmNzdicpO1xuXHRcdFx0bGV0IGNzdkNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlYWQoY3N2UGF0aCk7XG5cdFx0XHRsZXQgbGluZXMgPSBjc3ZDb250ZW50LnNwbGl0KCdcXG4nKTtcblx0XHRcdGNvbnN0IGluZGV4ID0gbGluZXMuZmluZEluZGV4KGxpbmUgPT4gbGluZS5zdGFydHNXaXRoKGZpbGVQYXRoICsgJywnKSk7XG5cdFxuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRsaW5lcy5zcGxpY2UoaW5kZXgsIDEpOyAgLy8gUmVtb3ZlIHRoZSBvbGQgZW1iZWRkaW5nXG5cdFx0XHR9XG5cdFx0XHRsaW5lcy5wdXNoKG5ld0VtYmVkZGluZy50cmltKCkpOyBcblx0XG5cdFx0XHRjb25zdCB1cGRhdGVkQ3N2Q29udGVudCA9IGxpbmVzLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICE9PSAnJykuam9pbignXFxuJyk7XG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLndyaXRlKGNzdlBhdGgsIHVwZGF0ZWRDc3ZDb250ZW50KTtcblx0XHRcdGNvbnNvbGUubG9nKGBVcGRhdGVkIGVtYmVkZGluZ3MgZm9yICR7ZmlsZVBhdGh9YCk7XG5cdFx0fSk7XG5cdH1cblx0XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBeUY7QUFDekYsMkJBQTRCO0FBQzVCLFdBQXNCO0FBQ3RCLGdCQUErQjtBQVkvQixJQUFNLG1CQUFxQztBQUFBLEVBQ3ZDLGVBQWUsQ0FBQztBQUNwQjtBQUVBLElBQXFCLFdBQXJCLGNBQXNDLHVCQUFPO0FBQUEsRUFBN0M7QUFBQTtBQUdJLHlCQUE2QixvQkFBSSxJQUFJO0FBQ3JDLHdCQUE0QixvQkFBSSxJQUFJO0FBQ3BDLDJCQUErQyxvQkFBSSxJQUFJO0FBQUE7QUFBQSxFQUV2RCxNQUFNLFNBQVM7QUFDWCxTQUFLLGlCQUFpQjtBQUN0QixVQUFNLEtBQUssYUFBYTtBQUN4QixTQUFLLGNBQWMsSUFBSSxpQkFBaUIsS0FBSyxLQUFLLElBQUksQ0FBQztBQUN2RCxTQUFLLFlBQVk7QUFDakIsVUFBTSxLQUFLLHdCQUF3QjtBQUNuQyxVQUFNLEtBQUsseUJBQXlCO0FBR3BDLFNBQUs7QUFBQSxNQUNELEtBQUssSUFBSSxNQUFNLEdBQUcsVUFBVSxDQUFDLFNBQVM7QUFDbEMsWUFBSSxnQkFBZ0IsdUJBQU87QUFDdkIs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QUFPLGtDQUFrQztBQUM3QyxtQkFBTyxLQUFLO0FBQUEsVUFDYjtBQUFBLFFBQ0Q7QUFBQSxNQUNELENBQUM7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLGlCQUFpQixVQUFrQjtBQUN4QyxVQUFNLFVBQVUsS0FBSyxJQUFJLE1BQU07QUFDL0IsUUFBSSxXQUFXO0FBQ2YsUUFBSSxtQkFBbUIsbUNBQW1CO0FBQ3pDLGlCQUFXLFFBQVEsWUFBWTtBQUFBLElBQ2hDO0FBRUEsVUFBTSxtQkFBd0IsVUFBSyxVQUFVLFFBQVE7QUFFckQsVUFBTSxhQUFrQixVQUFLLFVBQVUsYUFBYSxXQUFXLCtCQUErQixVQUFVLGNBQWM7QUFHdEgsVUFBTSxjQUFVLDRCQUFNLEtBQUssZUFBZSxDQUFDLFlBQVksZ0JBQWdCLENBQUM7QUFFeEUsWUFBUSxPQUFPLEdBQUcsUUFBUSxDQUFDLFNBQVM7QUFDbkMsY0FBUSxNQUFNLFdBQVcsTUFBTTtBQUFBLElBQ2hDLENBQUM7QUFFRCxZQUFRLEdBQUcsU0FBUyxPQUFPLFNBQVM7QUFDbkMsVUFBSSxTQUFTLEdBQUc7QUFDZixnQkFBUSxNQUFNLDRCQUE0QixNQUFNO0FBQ2hELFlBQUksdUJBQU8sMkJBQTJCO0FBQ3RDO0FBQUEsTUFDRDtBQUVBLFVBQUksZUFBZTtBQUNuQixjQUFRLE9BQU8sR0FBRyxRQUFRLENBQUMsU0FBUztBQUNuQyx3QkFBZ0IsS0FBSyxTQUFTO0FBQUEsTUFDL0IsQ0FBQztBQUdELFlBQU0sVUFBZSxVQUFLLGFBQWEsV0FBVywrQkFBK0IsZ0JBQWdCO0FBQ2pHLFVBQUksYUFBYSxNQUFNLEtBQUssSUFBSSxNQUFNLFFBQVEsS0FBSyxPQUFPO0FBQzFELFVBQUksUUFBUSxXQUFXLE1BQU0sSUFBSTtBQUNqQyxZQUFNLFFBQVEsTUFBTSxVQUFVLFVBQVEsS0FBSyxXQUFXLFdBQVcsR0FBRyxDQUFDO0FBRXJFLFVBQUksVUFBVSxJQUFJO0FBQ2pCLGNBQU0sT0FBTyxPQUFPLENBQUM7QUFBQSxNQUN0QjtBQUNBLFlBQU0sS0FBSyxhQUFhLEtBQUssQ0FBQztBQUU5QixZQUFNLG9CQUFvQixNQUFNLE9BQU8sVUFBUSxLQUFLLEtBQUssTUFBTSxFQUFFLEVBQUUsS0FBSyxJQUFJO0FBQzVFLFlBQU0sS0FBSyxJQUFJLE1BQU0sUUFBUSxNQUFNLFNBQVMsaUJBQWlCO0FBQzdELGNBQVEsSUFBSSwwQkFBMEIsVUFBVTtBQUFBLElBQ2pELENBQUM7QUFBQSxFQUNGO0FBRUQ7IiwKICAibmFtZXMiOiBbImZzIiwgImVycm9yIl0KfQo=
